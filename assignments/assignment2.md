# Assignment 2

## Problem statement.
**Problem domain:** Time Management 

Time management is of the utmost importance for people across all fields, focuses, and backgrounds. Whether professional, academic, or personal, to-dos seem to pile up, and it becomes increasingly valuable to have a way to tackle them. As a college student, it often feels like there is such a wide array of tasks to tackle, and it becomes incredibly daunting to try and piece together a logical plan for accomplishing them. However, good time management is not just a resume skill; it can grant you freedom to relax, socialize, and engage with hobbies. By staying on top of your to-dos, you can ultimately achieve a more balanced life. 

**Problem:** Interdependent To-Do Lists

Time management is, of course, a broad domain, and there are many different angles to take. Personally, one of the pressing issues I experience is the case of interdependent tasks complicating the creation of a to-do list. In my academics, this can look like needing to complete a reading before I can write a discussion post. In my personal life, I need to go grocery shopping before I can make my meal prep for the week. While each of these interdependencies may seem quite simple on its face, the web of connections can quickly become daunting, especially when I need to do the reading, discussion post, shopping, and cooking all in the same weekend. Often, it would be helpful to randomize the tasks at hand to avoid decision fatigue, but this is not made easy when tasks depend on one another. So, an app to digest these dependencies and produce a viable to-do lists would help address this problem.

**Stakeholders:**

1. College students: With a wide range of types of tasks to tackle, college students often encounter this problem. As young adults, they are also particularly benefited by tools to help develop these time management skills.

2. Working professionals: In a professional setting, different projects and tasks can have large numbers of interdependencies that make them likely to encounter this problem. 

3. Parents: When accounting for your own life and the life of others within your home, it can be incredibly difficult to account for all the different variables and the ways in which they interplay with one another. 

**Evidence & Comparables:** 
*Evidence:*
- [Benefits of To-Do Lists](https://hbr.org/2022/01/why-we-continue-to-rely-on-and-love-to-do-lists) - To-do lists can be a powerful tool for many people in managing their lives, so improving this tool to better reflect life would be to the benefit of at least some stakeholders.
- [Benefits of Randomness](https://medium.com/@haimson/using-randomness-to-improve-work-productivity-4c835d645204) - Randomness can help foster productivity.
- [To-Do List Flexibility](https://www.lifehack.org/articles/productivity/how-to-create-a-to-do-list-that-makes-you-smile.html#good-to-do-list) - While to-do lists are not a "one-size-fits-all" tool for time management, allowing for flexibility can benefit users.

*Comparables:*
- [General To-Do List Apps](https://zapier.com/blog/best-todo-list-apps/) - There are many strong to-do list platforms. In general, each focus on some specific aspect of time management like tackling procrastintion, time blocking, or preventing burnout. However, none seem to utilize the idea of dependency-minded randomness, meaning there is room in the market for this idea.
- [Apps with Interdependencies](https://www.reddit.com/r/productivity/comments/bkpwky/to_do_list_app_with_task_dependencies/) - When looking for tools that consider task interdependencies, there are few solid comparable options, each with notable design limitations of there own. However, the fact that there are users requesting such features reaffirms the demand for such a platform.


## Application pitch. 
**Task Tackler**

Often, as your list of to-dos grows, various tasks will depend on one another -- you probably shouldn't take out the trash until you've cleaned your room and you definitely can't clean the bathroom until you've gone to the store to buy more disinfecting wipes. However, it can be daunting to create a to-do list that captures all these relationships. That's where Task Tackler comes in. Task Tackler has a few key features that help tackle this commonly-encountered problem:

1. *Task Dependency* - While entering to-dos into the app, a user can denote its relationship to another task. These dependencies include "must happen before", "must happen after", "must happen immediately before", and "must happen immediately after". These relationships will be enforced across all task orderings, both those entered manually and those generated by the platform. This is the key feature to address the identified problem through consideration of dependencies in tasks.

2. *Order Generation* - Upon entering all their current tasks, users will want to create to-do lists. To do so, they have a few options. First, they can manually drag-and-drop tasks into their desired ordering, with reminders and enforcements of their dependencies. Alternatively, they can ask for the app the randomly generate a viable ordering based on the dependencies. With this, they also have the option for the random order to be revealed one at a time, showing the next task only once the previous is marked as completed. This feature allows users to take advantage of the benefits of randomization while still ensuring viable lists and provides the option for manual generation if preferred by the given user.

## Concept design. 
Design a set of concepts that will embody the functionality of your app and deliver its features. We expect you to have 3-5 concepts. Fewer than 3 concepts would probably mean limited functionality or a lack of separation of concerns; more than 5 likely suggests overambition or lack of focus. (Talk to us if you think you need more!) The deliverables are:

- The concept specifications, written in the standard form.

- Some essential synchronizations. You do not need an exhaustive collection of synchronizations, but should capture (a) any essential design ideas that involve multiple concepts; (b) representative syncs for kinds of sync that are common throughout your application (such as syncs for access control or notification).

- A brief note, at most half a page long, explaining the role that your concepts play in the context of the app as a whole. For example, if you have an authentication or authorization concept, you should say how it’s used to control access to other particular concepts. You should also explain how generic type parameters will be instantiated whenever it’s non obvious. (For example, that a generic user type will be bound to the users of an authentication concept is obvious; that the targeted items of an upvoting concept are users would not be.)

**Concepts**
```
concept TaskBank[Relation]
purpose allow for tasks to relate to one another
principle users can enter tasks and denote their relationship to other existing tasks.
state
    a set of Tasks with 
        a taskName String
        an optional description String
        a set of Dependencies with
            a depTask Task
            a depRelation Relation
actions
    addTask (name : String, ? desc : String ) : Task
        requires : there is not already a Task with taskName = name
        effects : a new Task with taskName = name and description = desc is returned and added to the set of Tasks
    deleteTask (task : Task) 
        requires : task is in set of Tasks
        effects : task is removed from set of Tasks
    addDependency (task1 : Task, task2 : Task, dependency : Relation) : Dependency
        requires : task1 and task2 are both in set of Tasks
        effects : for task1's set of Dependencies, task2 and dependency are added. for task2's set of Dependencies, task1 and the inverse of dependency are added.
    deleteDependency (task : Task, dependency : Dependency)
        requires : task has dependency in its set of Dependencies
        effects : dependency is removed from task's set of Dependencies and the corresponding Dependency is deleted from depTask's set of Dependencies
```
```
concept ListCreation
purpose allow for grouping of tasks into lists, subsets of the task bank
principle users can create a to-do list, select tasks from their task bank to add to it, and set a default ordering of the tasks according to their dependencies
state
    a set of Lists with
        a title String
        a set of ListItems with
            a task Task
            an orderNumber Number
        an itemCount Number
actions
    newList (listName : String) : List
        requires : no List with listName exists in set of Lists
        effect : new List with title = listName, itemCount = 0, and an empty set of ListItems is returned and added to set of Lists
    addTask (list : List, task : Task) : ListItem
        requires : listItem containing task is not already in list
        effect : a new listItem is created with task = task, taskStatus = incomplete, and defaultOrder = itemCount+1. itemCount is incremented. the new listItem is returned and added to list's set of listItems.
    deleteTask (list : List, task : Task)
        requires : a listIem containing task is in list's set of listItems
        effect : the listItem containing task is removed from list's set of listItems
    assignOrder (list : List, task : Task, newOrder : Number)
        requires : task belongs to a ListItem in list
        effects : task's ListItem gets defaultOrder set to newOrder and the ListItems with defaultOrders between the old value and new value are offset by one accordingly
```
```
concept Session[List, TaskStatus, OrderType, FormatType]
purpose a focused session of completing all tasks on a list
principle a user will "activate" a list to start a session and be given an ordered list (either default ordering or generated) of tasks on the list to complete
state
    a Session with
        a List with
            a title String
            a set of ListItems with
                a task Task
                an defaultOrder Number
                a randomOrder Number
                an itemStatus TaskStatus
            an itemCount Number
        an active Flag
        an ordering OrderType
        a format FormatType
actions
    changeSession (list : List)
        requires : 
        effects : makes list the Session's List with each randomOrder = defaultOrder, itemStatus = Incomplete, active = False, ordering = Default, and format = List
    setOrdering (newType : OrderType)
        requires : session's active Flag is currently False
        effects : ordering is set to newType
    setFormat (newFormat : FormatType)
        requires : session's active Flag is currently False
        effects: format is set to newFormat
    randomizeOrder ()
        requires : session's ordering is set to "Random"
        effects : each ListItems randomOrder value is updated at random, maintaining dependencies between tasks
    activateSession ( )
        requires : session's active Flag is currently False
        effects : session's active Flag is set to True
    startTask (task : Task)
        requires : task is in a ListItem for session's list, its status is currently "Incomplete", and no other task is "In Progress"
        effects: given ListItem's status is set to "In Progress"
    completeTask (task : Task)
        requires : task is in a ListItem for session's list and its status is currently "In Progress"
        effects : given ListItem's status is set to "Complete"
    endSession ( )
        requires : session's active Flag is currently True
        effects : session's active Flag is set to False
    
```

Generic Type Constructions:
```
Relation := ["Must happen before", "Must happen after", "Must happen right before", "Must happen right after"]
TaskStatus := ["Incomplete", "In Progress", "Complete"]
OrderType := ["Default", "Random"]
FormatType := ["List", "Reveal"]
```

**Syncs**


## UI Sketches. 
Construct some low-fidelity sketches of your user interface that show the primary user interface elements and their rough layout, annotated with pointers or comments to explain anything that might not be obvious. You should omit any error handling and standard interactions (such as user registration), but should aim to convey how the essential features appear and are used. You can use any tool you like to draw the sketches, or you can draw them by hand and scan them. You should include them in your design document as images referenced in markdown.


## User journey. 
Write a narrative that follows a single stakeholder as they encounter the problem and use your designed app to address it. Tell their story in chronological order: what triggers their need, the steps they take with the app (referring to the wireframes), and the outcome. A good journey should both persuade a reader that the problem is worth solving, and illustrate how your app might help solve it. The deliverable here is a few short paragraphs that form a coherent story but identify individual steps clearly, and that reference your sketches when appropriate.